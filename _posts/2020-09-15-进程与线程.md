---
layout:     post                    # 使用的布局（不需要改）
title:       进程与线程                # 标题 
subtitle:                           #副标题
date:       2020-09-15              # 时间
author:     ONLYUNIVERSE            # 作者
header-img: img/post-bg-2015.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    OperatingSystem
---

### 进程

进程就是正在执行程序的实例

CPU在多个运行的进程之间不断切换，在宏观看来，每个进程都分配到一个虚拟CPU

进程创建后，父进程与子进程有不同的地址空间，在一个进程中修改的数据不会影响另一个进程

进程分为程序段、数据段和进程控制块：

1. 程序段用来存放程序员编写好的程序

2. 数据段用来存放程序运行时需要访问储存保护的数据

3. 进程控制块用来描述进程的基本情况和活动过程；在进程被挂起时保存上下文，以便调度程序启动或重新启动该进程

#### 进程的创建

在大部分复杂的系统中,需要某种方法创建或撤销线程

* 系统初始化

启动操作系统时，通常会创建若干进程，以完成所需的任务

* 正在运行的程序执行了创建进程的系统调用

在所从事的工作能够划分为多个不会互相影响的的进程时，创建进程能够有更好的工作效率

* 用户请求创建一个新进程

在某些系统中，用户能够同时开启多个进程，并与某进程进行交互

* 一个批处理作业的初始化

多在大型机的批处理系统应用

####　进程的终止

* 正常退出

* 出错退出

* 严重错误

* 被杀死

#### 进程的层次结构

某些进程自身被创建后，又可以创建新的子进程

在UNIX中，启动映像运行一个init程序，init命令再创建登录相关的进程，用户通过登录输入在终端的命令又启动了更多的进程

在Windows中，没有进程层次的概念，所有的进程地位是相同的；父进程在创建子进程的过程中会得到一个令牌(句柄)，得到令牌的进程可以控制特定子进程

#### 进程的状态

* 运行态：CPU空闲，没有被阻塞

* 就绪态：CPU空闲，但CPU资源没有分配给进程

* 阻塞态：由于输入或其他外部条件未就位，即使CPU空闲，进程也不能运行

#### 进程的实现

操作系统维护着进程表

进程表中保存着处于就绪态或阻塞态的进程的信息和其他维持系统正常运行的文件，保证进程可以随时继续启动

一旦发生中断，中断硬件就将多个存有中断信息的寄存器压入堆栈，再跳转至指示的位置

### 线程

线程是计算机操作系统能够调用的最小单位，是进程的实际运作单位

当存在大量的计算或其他需要处理的任务时将不同的琐碎任务交由多个小的进程完成是有益的

线程在进程中运行，共享系统分配给进程的资源；也可以申请独占资源

每一个线程都拥有自己的堆栈，用以存储相应过程中产生的局部变量和执行历史等(上下文)

####　在用户空间内实现线程

计算机拥有虚拟内存，将虚拟内存空间分为两部分，一部分划分给操作系统的内部核心程序，称为内核空间；另一部分划给各个进程，称为用户空间

在用户空间内调用各个线程，可以通过线程表迅速完成对线程的阻塞，启动或转换；由于这些操作都是在本地空间内完成的，不需要调用内核或是切换上下文，线程的调度十分快捷

阻塞系统调用带来的问题：若一个线程在被调用的过程中被阻塞了，不能及时读取到需要的输入，就会影响乃至停止其他线程；为了防止这类情况出现，使用*包装器*检查该线程的调用过程中是否安全，若可能被阻塞，则不调用该线程

线程独占CPU带来的问题：由于没有时钟中断，当一个线程不放弃CPU的独占时，该进程的其他线程就不能够运行

#### 在内核中实现线程

内核中拥有记录所有线程的线程表，希望进行调用的线程通过系统调用对线程表进行更新完成线程的创建和撤销

当一个进程阻塞时，内核根据某种规则，选择运行另一个线程或不运行

### 进程间通信

#### 竞争条件

不同的进程对同一资源进行修改，由于时钟中断和CPU调用时序，可能不同的进程对同一份变量的认识是不一样的

#### 临界区

为了避免竞争条件，在涉及共享内容时，需要设计临界区以避免多个进程对同一个共享内存进行读写操作

当一个进程进入了临界区时，其他试图进入临界区的进程就会被挂起直至该进程离开临界区

#### 忙等待的互斥

* 屏蔽中断：一个进程进入临界区后立即屏蔽所有中断，离开前再打开中断，这样可以避免其他进程打扰；但系统将屏蔽中断的权利下放给用户，这是不明智的，因为恶意程序很有可能不再打开中断；屏蔽中断的操作更适合操作系统而不是用户

#### 睡眠与唤醒

对于*生产者-消费者*问题，我们规定：当缓冲区的信息满时，生产者睡眠，否则生产者向缓冲区放入信息；当缓冲区的信息空时，消费者睡眠，否则消费者从缓冲区取出信息

意外情况：消费者发现缓冲区空，决定睡眠但此时调度程序决定暂停消费者的动作而开始运行生产者；生产者放入信息，逻辑上认为消费者在睡眠状态，决定唤醒消费者；但消费者逻辑上未睡眠，于是测试原先读取并存放在堆栈中的缓冲区的值，认为缓冲区为空，决定继续睡眠；此时生产者仍在不断地向缓冲区放入信息，一旦缓冲区满，生产者也将睡眠，系统死锁

#### 信号量

信号量通过整型变量保存，down和up操作信号量表示唤醒和睡眠

执行down操作时，检查信号量是否为0；若大于0，则进行减一操作，信号量为0时，进程睡眠

当有多个进程在同一个信号量上睡眠时，系统随机挑选一个执行up操作，使该进程继续执行

down和up操作都是原子性的，不可分割的

#### 互斥量

用一个整型量表示解锁和加锁，若互斥量是解锁的，调用的进程或线程则调用成功，自由进入临界区；若已加锁，调用线程被阻塞，直到锁被释放；但被阻塞的进程并不进行忙等待

####　管程

管程是由过程、变量及数据结构组成的一个集合

任意时刻，管程中只能有一个活跃的进程；进入管程的互斥行为由编译器执行

* 条件变量：配合相关函数，使调用进程阻塞

使用管程则不必担忧出现sleep-wakeup的失败状况，因为管程中严格互斥
