---
layout:     post                    # 使用的布局（不需要改）
title:       内存管理                # 标题 
subtitle:                           #副标题
date:       2020-09-24              # 时间
author:     ONLYUNIVERSE            # 作者
header-img: img/post-bg-2015.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    OperatingSystem
---

### 无存储器抽象

内存直接将物理地址暴露给进程

如果同时运行多个进程可能会导致某个进程所执行的内容将另一进程覆盖

如果不采取抽象,就可能会导致写覆盖与重定位的问题

### 地址空间

地址空间是一个进程可用于寻址内存的一套地址集合；通常情况下，不同的进程拥有独立的地址空间

* 基址寄存器与界限寄存器：基址寄存器标识了进程的开始，界限寄存器标识进程的结束；当进程中的物理地址被送到硬件进行寻址时，在物理地址发送到内存总线前硬件将地址加上基址寄存器的值，即动态重定位

使用基址寄存器的缺点在于计算量大，耗时长

#### 交换技术

在进程占据内存一段时间后，该进程可能被杀死或进入磁盘，导致内存中留下空闲区；为了让进程更好地运行，需要将空闲区集中利用

#### 空闲内存管理

* 位图：将内存划分为固定长度的分配单元，0标识空闲、1标识占用

* 链表：链表中的每一个结点包括

1. 进程或空闲区的指示标识

2. 起始地址和长度

3. 指向下一节点的指针

### 虚拟内存

大多数时候进程没有必要将自己所有的代码装入内存，此时我们给每一个进程分配一个独立的虚拟内存空间；当进程需要引用存放在虚拟内存中的某个内存地址时，由硬件进行映射；虚拟内存中的某一块地址空间映射到相  应的内存中，即页面映射到页框

但虚拟内存仍比内存大，不可能将所有的页都同时映射到内存中；当内存空间不足以继续映射新的虚拟内存时，或是程序访问了未映射的页面，此时CPU陷入内核陷阱(缺页中断):操作系统通过某种原则选择一个页框,回收页框中的信息,并将需要映射的页面写入,然后重新启动引起陷阱的指令

#### 页表

页表存储虚拟内存与物理内存之间的映射关系,包括:高速缓存禁止位、访问位、修改位、保护位、有效位和页框号

* 转换检测缓冲区(快表)：实际上计算机会对少量的页面进行多次的访问，于是将这部分信息保存在快表中，需要转换虚拟地址时，首先访问快表

### 页面置换算法

当发生缺页中断时，操作系统在内存中选择一个页面将其换出内存，以调用新的页面；如果需要调出的页面在内存驻留时被修改，则需要将该页面回写至磁盘

#### 最优页面置换算法

判断多个页面中谁在更多的指令后才被调用，选择之进行页面置换

#### 最近未使用页面置换算法

选择在最近的一个时间周期内没有被频繁修改的页面

#### 先进先出页面置换算法

最先进入链表的页面被置换

#### 第二次机会页面置换算法

为了避免先进先出算法将使用频繁的页面过早换出，若最先进入的页面最近被修改，则将其放入表头，然后继续寻找

#### 时钟页面置换算法

使用时钟指针指向最老的页面，若该页面最近未被修改，则淘汰之

### 分页策略

#### 全局分配策略与局部分配策略

* 全局分配策略指在发生缺页中断时，在整个内存中寻找满足条件的片段进行处理

* 局部页面置换指在分配给发生缺页中断的内存片段中寻找舍弃的片段

#### 负载控制

为了合理分配有限的内存资源，满足需要更多内存的活跃进程，可以将某些使用频率低交换入磁盘保存

#### 页面大小

页面过大，会导致一个文件被分成两份或多份，形成大量的碎片，造成内存的浪费；

页面过小，又会导致页数增多，页表增大，寻道和延迟的时间延长；

有时系统可能在不同的空间使用不同的页面大小

#### 分离空间

地址空间是有限的，不能将全部的数据写入

于是将指令和数据设立分离的地址空间，程序处理器和数据处理器相互独立，称为哈佛结构

#### 共享页面

当有多个用户使用同一个程序时，可以共享程序页表，效率更高

当两个进程进行共享，其中一个被决定移走，此时与该进程相关的页面就会被从内存中抛弃，而这将导致另一与该进程共享页表的进程出现大量的缺页中断

为了防止这种情况，需要使用数据结构记录共享页面

#### 共享库

* 写时复制：当一个进程更新了数据，就会触发只读保护，并引发操作系统陷阱，给该进行写操作的进程一个副本，之后的写操作不再触发陷阱；只当进程首次进行写操作时才给予副本，称为写时复制

加载程序时，需要扫描库文件，调用定义函数，并将库中的需要使用的函数加载出来；如果每一个程序都加载属于自己的库，将会浪费大量的内存空间

如果使用共享库，当其他程序已经加载了共享库中的所需的相关函数，该进程就无需再进行加载了

但是，不同的进程在使用同一个共享库时，进程所调用的地址的移动距离不同，不能使用重定位

在编译共享库时，用一个特殊的编译选项使编译器不使用绝对地址

本文共{{ page.content | strip_html | strip_newlines | remove: " " | size }}字符
