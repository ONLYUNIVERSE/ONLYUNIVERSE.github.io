---
layout:     post                    # 使用的布局（不需要改）
title:      操作系统综述            # 标题 
subtitle:                           #副标题
date:       2020-11-20              # 时间
author:     ONLYUNIVERSE            # 作者
header-img: img/post-bg-2015.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
description: 计算机系统中，操作系统是如何发挥作用的
tags:                               #标签
    OperatingSystem
---

## 1 概述

1. 操作系统是平铺在计算机硬件上的第一层辅助软件，消除了不同厂商型号的硬件设备的差异，使软件开发者不必考虑过于底层的操作指令而可以普适地将软件运行在不同的主机上。

2. 由于硬件指令的复杂性，非专业人群便不可能方便地使用计算机。操作系统一方面能够直接操作硬件，合理地分配计算机系统中众多的资源，另一方面又可以向用户提供相对友好的界面，满足用户提出的各项需求，也就承担着用户与硬件之间进行沟通的任务

### 1.1 操作系统基本特征

1. 并发：宏观上多个任务同时进行，微观上多个任务交替执行
2. 共享：分为互斥共享(同一时间只能有一个进程访问)和同时访问(宏观上多个进程同时对资源进行操作)
3. 虚拟：将一个物理实体从逻辑上划分为多个，供多个用户或程序使用，以提高资源的利用率
4. 异步：由于某进程需要的资源不一定能及时提供，一个进程需要经过多次等待才能完成任务

### 1.2 专业名词概览

1. 内核：内核是操作系统的最基本部分。是控制计算机上所有其他程序的程序。
2. 微内核：指操作系统中最核心基本的部分
3. 机制：实现某功能的具体执行机构
4. 策略：在机制的基础上通过算法等实现优化
5. 处理机：CPU

### 1.3 操作系统主要功能

1. 处理机管理：将CPU按一定方法分配给进程
2. 存储器管理：合理分配内存空间
3. 设备管理：妥当处理用户的I/O要求
4. 文件管理：对文件读写、存储、目录的管理

## 2 进程 [->](https://onlyuniverse.github.io/2020/09/15/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/)

### 2.1 专业名词概览

1. 进程：进程是程序的一次**运行**，包括程序代码部分、运行所需数据部分和进程控制块
2. 原语：原子性的语言，指在执行过程中不可中断
3. 套接字：一个存储通信地址、端口号等的数据结构
4. 内核：指操作系统中最基本的部分
5. 内核空间：指将寻址空间划分为受保护的，存储敏感指令的内核空间部分和用户空间部分

### 2.2 进程所解决的问题

计算机系统异常庞杂，需要完成的任务不可胜数，若将某一系列的任务划拨给一个对象令其完成，负责不同任务的对象相互配合，会使整体任务更具简洁性、高效性、灵活性；模块化的操作让任务之间产生隔离，减少了单一故障点产生的几率。

### 2.3 进程所带来的问题

计算机系统将不同的指令分割为进程，问题在于如何处理众多的进程之于有限的资源之间的矛盾。

资源是有限的，这种有限性体现在资源数量的有限性与资源访问权的有限性。计算机系统须适当地将资源分配给需要的进程，以供任务的完成。

系统重要资源(CPU、内存)的分配体现在进程的不同状态上；或者说，系统通过对重要资源的分配实现对进程运行状态的控制

### 2.4 如何实现对进程的管理

对于许多硬件资源，在同一时刻不允许多个进程进行访问，需要将访问权抽象出来，供多个进程争夺。

同时，系统可以维护一个阻塞队列，存放因没有可用资源而阻塞的进程，伺有可用资源后唤醒

### 2.5 进程之间如何通信

#### 2.5.1 管道通信

管道的本质就是一个共享文件，写进程将需要传输的数据以数据流的形式写入管道，读进程则将数据从管道中读出

#### 2.5.2 客户机-服务器系统

1. 发送端利用套接字(一个描述通信类型的数据结构)，将套接字与接口绑定，与固定的服务端接口进行通信
2. 发送端与接收端保持一对负责远程过程的进程，同时还有一对相对应的存根(负责打包相关数据的进程)

### 2.6 线程

#### 2.6.1 线程相较于进程有哪些区别

1. 线程是调度与分派的基本单位，也是独立运行的基本单位
2. 线程的创建、切换和撤销只需要修改少量寄存器等内容，难度和代价远小于进程
3. 同一个进程可以为相同的任务划分为不同的线程去执行，提高执行效率
4. 同一进程中的不同线程是为了完成同一个任务而创建，可以尽可能地共享资源

#### 2.6.2 线程的实现

1. 内核型线程在内核中创建、阻塞、撤销与切换；多处理机结构中，可以有多个线程同时运行
2. 用户级线程不受内核干涉，在用户程序中实现，可以自行调度

#### 2.6.3 内核态

一些应用程序必须执行某些涉及内核的操作，这时需要从用户态陷入内核态

具体来说，首先将程序需要存放使用的数据拷贝到内核空间，再执行```陷阱指令```，执行系统调用，CPU执行指定的内核命令，读取事先存放的数据，完成相关任务；完成操作后，操作系统重置CPU，程序重新回到用户态

## 3 调度算法[->](https://onlyuniverse.github.io/2020/11/03/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/)

### 3.1 专业名词概览

1. 处理机：即CPU
2. 上下文：指CPU执行某进程是所处的环境，即寄存器和程序计数器
3. 实时操作系统：考虑的首要条件不是吞吐量，而是能否在规定的时间内完成所需完成的任务

### 3.2 调度算法的目的

计算机系统中的CPU资源是有限且宝贵的，而运行的进程数目又远大于CPU个数，为了更快地完成用户要求，需要合理地分配计算资源，得以最大化利用

### 3.3 调度算法的类别

1. 轮转调度算法：根据FCFS策略，给所有的就绪进程安排一个时间片；若时间片未完而进程结束，启动新的时间片赋给新的进程
2. 优先级调度算法：根据实际需要，赋给每个进程一个优先级，系统根据优先级分配CPU资源
3. 多队列调度算法：在多处理机系统中,设置多个就绪队列，分别给不同队列、不同进程赋予不同的优先级，再逐一分配给不同的处理机
4. 多级反馈队列；同样设置多个就绪队列，给不同的就绪队列分配不同大小的时间片，时间片越小的队列优先级越高；进程从优先级最高队列逐级下落，直至完成 

### 3.4 实时调度基本条件

1. 提供程序的截止时间、处理时间、资源要求和就绪时间
2. 系统处理机的能力须满足任务的需求
3. 适时地采用抢占式或非抢占式调度机制
4. 能够快速地进行切换

### 3.5 死锁

当多个进程持有临界资源而不放弃，且还想占有更多被占用资源否则不运行时，发生死锁

死锁指持有资源而不能运行，保持僵持状态；饥饿指没有资源导致不能运行

## 4 存储器管理[->]((https://onlyuniverse.github.io/2020/09/24/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/))

### 4.1 程序在执行前的准备工作

1. 编译：执行编译程序，形成目标模块
2. 链接：将目标模块链接在一起，形成完整模块
3. 装入：将完整模块装入内存

### 4.2 程序装入

程序中的大量指令由逻辑地址规划顺序，指令中的地址跳转同样基于逻辑地址；将程序装入后，逻辑地址将与物理地址一一映射

但内存资源是宝贵的，一个程序不能永远占有固定的物理地址；为了合理利用内存资源，使用不同的内存分配方法，为了程序的物理位置发生变化后仍能正确执行，需要使用重定位寄存器

### 4.3 内存连续分配方法

1. 固定分区分配：为了同时运行多个程序，将内存预先划分为固定大小的分区，提供给不同的进程
2. 动态分区分配：为了减少内存空间的浪费，在进程进入内存时为不同大小的内存分配适合大小的分区
3. 动态可重定位分区分配：随着程序的不断运行，系统剩余可用内存空间逐渐缩小，也就难以容纳较大的程序；为了利用分散在内存中的小空闲分区，在合适的时间将已有的程序进行```紧凑```，以合并分散的空闲区

*动态分区分配情况下，程序运行完毕后，系统收回分区，并视情况合并*

### 4.4 分页存储

将逻辑空间划分为页，将物理空间划分为块；块与页大小相等，块与块，页与页之间地址不连续

为了充分利用不可避免地产生的碎片化的空闲区，将页分散地存放在内存中，并使用页表记录页的存放位置；若页的数量过多，导致不能在一个页中记录所有的页位置，需要使用二级页表存放一级页表的存放位置

*反置页表：每个进程需要一个独立的页表，当进程数量过多时，需要大量的空间存放页表；为了减少存储空间的浪费，只为整个系统基于物理地址构建反置页表，通过检索页表项寻找已装入内存的程序块*

### 4.5分段存储

将程序根据用户的需要分为若干块，并建立物理地址与程序块之间的映射关系

## 5 虚拟存储器

### 5.1 虚拟存储器存在的意义

当程序所要求占用的内存过大时，内存中可能只能运行一道程序，甚至无法运行。为了更好地分配内存，满足更多的程序需求，需要对存储器进行虚拟化。

### 5.2 虚拟存储器存在的可能性

1. 程序在运行的过程中，大部分时间是在按逻辑地址顺序执行的，很少有跨越长距离的调度
2. 程序中存在大量循环结构，在相当长的时间内程序是在有限的空间内运行的

### 5.3 实现的前提要求

#### 5.3.1 请求页表

虚拟存储器系统需要将程序分为若干页，只将一部分放在内存中执行，外存中保持所有程序的副本

页表将记录：
1. 该页是否在内存中
2. 该页在某段时间被访问的次数
3. 该页是否被修改了
4. 该页的外存地址

#### 5.3.2 缺页中断

由于程序并不是全部位于内存中，当程序执行到内存中不存在的位置时，就需要将相应的页面从外存中调入，此时向CPU发出缺页中断

不同的系统中指令的长度不同，一条指令有可能是跨越两个页面的，所以单条指令执行的过程中也有可能发生缺页中断

将页面调入内存后只更新页表，而将快表置为非法，不能再次访问

#### 5.3.3 地址变换

地址变换机构负责
1. 检索快表
2. 检索内存
3. 保存现场
4. 换入换出
5. 修改页表项
6. 产生物理地址

### 5.4 系统如何访问文件

1. 查找快表：如果有快表，快表的查询速度快，自然先从快表中查询是否有该页，然后访问内存
2. 查找页表：若快表中没有需要的页，则寻找内存中是否有该页，然后访问内存
3. 缺页中断：若页表中也没有该页，说明没有调入内存，需要使用页面置换算法将外存中的页调入内存
4. 查找页表：中断结束后，内存中就有了需要的页，此时再次查询需要访问的页面的地址，然后访问内存

### 5.5 页面置换算法

#### 5.5.1 最佳置换算法(OPT)

根据给出的访问顺序，将之后永远不需要访问的页面换出，若都需要访问，则换出最后需要访问的页面

#### 5.5.2 先进先出置换算法(FIFO)

选择当前在内存中驻留时间最长的页面置换

#### 5.5.3 最近最久未使用置换算法(LRU)

为内存中每个页面设置一个寄存器，每访问一次该页面，则将相应寄存器的首位置1

每隔一定时间，将寄存器右移一位

于是，寄存器的值越小，代表在最近一段时间，该页最久未被访问

#### 5.5.4 最少使用置换算法(LFU)

与LRU算法类似，只是最后对寄存器进行求和计算后比较

## 6 输入输出系统[->](https://onlyuniverse.github.io/2020/09/29/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/)


